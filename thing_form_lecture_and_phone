// #include <cstdint> //defiens integer types regardless of os
// #include <iostream>
// #include <string>
// #include <cstdlib> // for system("cls"); setting
// #include <limits>
// #include <algorithm>


// using namespace std;


// const int MAXCONTESTANTS = 30;
// const bool DEBUGMODE = 0;

// struct Contestants {
//     int ID;
//     bool isObjectUsed = 0;
//     string name; 
//     int age;
//     bool isWoman = 1;
//     double hipCirc;
//     double shoulderCirc;
//     double calfCirc;
//     double neckCirc;
// };

// #define deBugInfo(message) if (DEBUGMODE) { cout << message << endl; } // macro

// /*
// int searchContestantID (Contestants contestant[], const double& targetValue, const int& startIdx){
//     return searchContestantNumberPROTOTYPE(contestant,0, targetValue, startIdx); 
// }

// int searchContestantAge (Contestants contestant[], const double& targetValue, const int& startIdx){
//     return searchContestantNumberPROTOTYPE(contestant, 3, targetValue, startIdx);
// }

// int searchContestantAge (Contestants contestant[], const double& targetValue, const int& startIdx){
//     return searchContestantNumberPROTOTYPE(contestant, 3, targetValue, startIdx);
// }
// */
// //Holly grail of search in contestant function but maybe will be split to smaller functions
// int searchContestantNumberPROTOTYPE(Contestants contestant[], const int& searchMode, const double& targetValue, const int& startIdx) {

//     for (int i = startIdx; i < MAXCONTESTANTS; i++) {

//         // Skip empty slots unless you are specifically looking for 'isObjectUsed' (case 1)
//         if (searchMode != 1 && !contestant[i].isObjectUsed) continue;

//         double currentVal = 0;
//         bool validMode = true;

//         switch (searchMode) {
//             case 0: currentVal = contestant[i].ID; break;
//             case 1: currentVal = contestant[i].isObjectUsed; break;
//             // Case 2 (Name) is removed -> Strings cannot be doubles!
//             case 3: currentVal = contestant[i].age; break;
//             case 4: currentVal = contestant[i].isWoman; break;
//             case 5: currentVal = contestant[i].hipCirc; break;
//             case 6: currentVal = contestant[i].shoulderCirc; break;
//             case 7: currentVal = contestant[i].calfCirc; break;
//             case 8: currentVal = contestant[i].neckCirc; break;
//             default: validMode = false; break;
//         }

//         if (validMode && currentVal == targetValue) {
//             deBugInfo("SYSTEM: Found match at index: " << i);
//             return i;
//         }
//     }
//     return -1;
// }

// int getNextFreeSlot(Contestants contestant[], int startIdx) {
//     return findNextIndexByStatus(contestant, 0, startIdx);
// }


// int getNextUsedSlot(Contestants contestant[], int startIdx) {
//     return findNextIndexByStatus(contestant, 1, startIdx);
// }

// void printContestant(Contestants contestant[], int index){

//     deBugInfo("Index: " << index);
//     cout << "ID: " << contestant[index].ID << "   ";
//     cout << "Name: " << contestant[index].name << "   ";
//     cout << "Age: " << contestant[index].age << "   ";
//     cout << "Gender: " << ((contestant[index].isWoman) ? "Woman" : "Man") << "   ";
//     cout << "HipCirc: " << contestant[index].hipCirc << "   ";
//     cout << "ShoulderCirc: " << contestant[index].shoulderCirc << "   ";
//     cout << "CalfCirc: " << contestant[index].calfCirc << "   ";
//     cout << "NeckCirc: " << contestant[index].neckCirc << "   ";
//     cout << endl;
// }


// Contestants randomContestantGenerator (int ID) 
// {
// Contestants cont;
// string names[60] = {
//     "Arden", "Lyra", "Corvin", "Selene", "Marek", "Isolde",
//     "Dorian", "Kara", "Theron", "Vera", "Cassian", "Mira",
//     "Lior", "Sabine", "Jarek", "Elara", "Nolan", "Talia",
//     "Caelan", "Rhea", "Lucian", "Nadia", "Silas", "Iris",
//     "Rowan", "Delphine", "Kellan", "Freya", "Orion", "Maeve",
//     "Darius", "Lina", "Anders", "Helena", "Stellan", "Cora",
//     "Evander", "Seren", "Malek", "Yara", "Quentin", "Selah",
//     "Brennan", "Elowen", "Tristan", "Nova", "Soren", "Elise",
//     "Ronan", "Astrid", "Leander", "Nerina", "Magnus", "Ayla",
//     "Cyrus", "Junia", "Therin", "Sabriel"
// };
//     //TODO: put srand(time(0)); in the header
    
//     cont.isObjectUsed = true;
//     cont.name = names[rand() % 60];
//     cont.age = rand() % 85 + 15;
//     cont.isWoman = rand() % 2;
//     if (cont.isWoman){
//        cont.hipCirc = (rand() % 600)/100.0  + 31;
//        cont.shoulderCirc = (rand() % 1600)/100.0  + 95;
//        cont.calfCirc = (rand() % 2100)/100.0  + 95;
//        cont.neckCirc = (rand() % 700)/100.0  + 33;
//     }else{
//        cont.hipCirc = (rand() % 800)/100.0  + 36;
//        cont.shoulderCirc = (rand() % 2100)/100.0  + 110;
//        cont.calfCirc = (rand() % 1600)/100.0  + 90;
//        cont.neckCirc = (rand() % 800)/100.0  + 34;
//     }
//     return cont;
// }    

// int main(){
// srand(time(0));
// Contestants contestant[MAXCONTESTANTS];

// //TODO: Remove endl in deBugInfo and add endl where needed after change
// //TODO: Implement new function:easyContInit
// //TODO: Remove extra spaces in print contestant 3?4 line
// //TODO: Add defalult values in struct Contestants
// /*contestant[0] = easyContInit(1,1,"Bofadese",35,1,3.5,5.6,7.8,70);
// contestant[1] = easyContInit(2,1,"Ligma",67,1,6.5,2.4,9,10);
// contestant[2] = easyContInit(3,1,"Candys",47,1,4.5,3.4,7,6);
// contestant[3] = easyContInit(4,1,"Deze",39,1,3.6,57,19,9);
// contestant[4] = easyContInit(5,1,"Tuov",68,0,1,2,33,4);
// contestant[5] = easyContInit(6,1,"Sugondese",16,0,6,4,7,8);
// contestant[6] = easyContInit(7,1,"Nanaia",17,1,4,5,6,7);
// */
// //                clearConsole(CLEARCONSOLE);


// for(int i = 0; i < 5;i++){
//     contestant[i] = randomContestantGenerator(i);
// } 
//                 cout << "------All contestants------" << endl;
                
//                 for(int i = 0; i < MAXCONTESTANTS; i++){

//                     int validIndex = findFreeIndex(contestant, 1, i);
//                     i = validIndex;
//                                        //When findFreeIndex is done it outputs -1. This "if" breaks when detects -1;
//                     if (validIndex == -1) {
//                         cout << endl;
//                         break;
//                     }
                    
//                     printContestant(contestant, validIndex);
//                 }
// //                break;

// /*                int i = 0;
//                 int lastIndex = 0;

//                 do{
                    
//                     //if next contestant is not in use remoove stop the program
//                     if (contestant[i+1].isObjectUsed == 0){
//                         break;
//                     }
//                     if(contestant[i].age > contestant[i+1].age){
//                         //swap contestant places
//                         Contestants placeHolder = contestant[i];
//                         contestant[i] = contestant[i+1];
//                         contestant[i+1] = placeHolder;

//                     } else if (i == 0){
//                         lastIndex++;
//                         i = lastIndex;

//                     } else {
//                         i--;

//                     }

//                 } while(i != MAXCONTESTANTS);
//                 */
// }
// in.clear();
// in.seekg9(0) -> at start of file

// radn things
// #include <cstdlib>
// #include <ctime>
// #include <iostream>
// using namespace std;

// int GenRandomNumber(){
//     srand(time(nullptr));
//     int min = 1;
//     int max = 100;
//     int randomInt = min + rand() % (max- min + 1);
//     cout << "Random int between 1 - 100"<< randomInt<< endl;
    
//     return 0;
// }

// int main(){

//     random_device rd;
//     mt19937 gen(Rd[1]);
//     uniform_int_distribution<> dist(1,100);
//     int randomInt = dist(gen);
//     cout << randomInt << endl;

// }

// //bindary writing
// //RAKITIN
// //int a  = 50;//a -> 0x00000032 -> 00 00 00 32; file ->int 00 00 00 32
// #include <cstdlib>
// #include <ctime>
// #include <iostream>
// #include <fstream>

// using namespace std;

// struct record{
//     char name[100];
//     int num;
//     double amount;
// };

// int main(){

//     const int max = 100;
//     int count = 0;
//     record r[max];
//     record rin[max];
//     cout << "How many recordsto add: ";
//     cin >> count;
//     for(int i = 0; i < count; i++){
//         cout << "No" << (i+1) << endl;
//         cin >> r[i].name;
//         cin >> r[i].num;
//         cin >> r[i].amount;
//     }
//     cout << "Binary wtiting";
//     ofstream out("db.bin", ios_base::binary);
//     if(out){
//         out.write((char*)&count,sizeof(int)); // sizeof(count);
//         out.flush(); //puts buffer for saving, otherwise the save will be done at .close();
//         for(int i = 0;i < count; i++){
//             out.write((char*)&r[i], sizeof(record));
//             out.flush();
//         }
//         out.close();
//     } else {
//         cout << "!!!Error reading\n";
//         int elems = 0; 
//         ifstream in("db.bin",ios_base::binary);
//         if(in){
//             in.read((char*)&elems,sizeof(int));
//             for(int i = 0;i < elems; i++){
//                 record temp;
//                 in.read((char*)&temp,sizeof(record));
//                 rin[i] = temp;
//             }
//             in.close();
            
//         } else {
//             cout << "!!!Error reading file\n";
//             in.close();
//         }
//         for(int i = 0; i <elems; i++){
//             cout << "No " << (i + 1) << endl;
//             cout << rin[i].name << " ";
//             cout << rin[i].num << " ";
//             cout << rin[i].amount << endl;
//         }
//     }
//     return 0;    
// }

// //WRITE AFTER CHANGE OF VALUE FOR SOMETIHNG IN RECORD
//  (number of elemenets folowing)   
//   |
//   |
//  \ /
// [int][record][record][record] 
//   3 |       |               |
//     0       1
// 1. size in bytes
// 2. calculating position  

// ifstream::postype filesize(const char* fname){
//     unsigned long size = 0;
//     instream in(frame, ios_base::ate| ios_base::binary);
//     size = in.tellg();
//     in.close();
//     return size;
// }

// 1. one recording  =sizeof(record) =  112;
// 2. filesize = 340bytes
// 3. int elem = 2
// int pos = (elem - 1) * sizeor(record) +sizeof(int) = 116
// //pos < filesize
// out.seekg(pos);//116
// out.write((char*)&r, sizeof





// //katrova

// #include <iostream>
// #include <string>
// #include <cstdlib>
// #include <fstream>

// using namescapece std;

// const int N = 10;
// fstream fp;
// //allowed to globlay decalre filles

// struct Student{
//     char name[10];
//     char from[9];
//     char spec;
//     int oceki[3];
//     double srusp;
// };


// //prototoypes
// void  create_file(string fname, int &size);
// void create_array(Studnt x[], int size,stirng fname);

// void main(){
//     student stud[N];
//     int size;
//     const string FNAME = "Student.dat";
//     create_file(FNAME,size);
//     cretae_array(stud, size, FNAME);
// }

// void create_file(string fname, int& size){
//     coud << endl << "Kolko recorda?";
//     do{
//         cin >> size;
//     }while(size > N || size < 0);
//     Student st;
//     fp.opem(ganme,ios::out|ios::binnary);//if text: remoove binnary
//     for(int i = 0 ; i < size; i++){
//         cout << endl << "Enter name: ";
//         cin.getline(st.name, 10);
//         //if text:fp <<st.name;
//         cin.getline(st.fnom, 9);
//         //if text: fp << st.fnom
//         cin.getline(st.spec, 10);
//         for(int j = 0; j < 3;j++)
//             cin >> st.ocenci[j];
//             //if text: fp << st.ocekni[j];
//         fp.wirte((char*)&st, sizeof(student));
//         fp.close();
//     }
// }

// void create_array(Studnt x[], int size, stirng fname){
//     fp.open(fname, iox::ate |ios::binary);
//     long k = fp.tellg(); fp.seekg(0L,ios::beg);
//     fp.read((char*)x, k); k = size * sizeof(Strudent);
    
//     //if test:
//     fp.getline(x[i].name
    
    
// }

